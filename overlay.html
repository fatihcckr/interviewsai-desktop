<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>InterviewsAI</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: rgba(26, 26, 26, 0.50);
      color: white;
      overflow: hidden;
      pointer-events: none;
    }

    .container {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .header {
  background: rgba(45, 45, 45, 0.5);
  padding: 8px 16px 8px 0px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #404040;
  pointer-events: auto;
  -webkit-app-region: drag;  /* ‚Üê YENƒ∞: header'dan s√ºr√ºklenebilir yap */
  cursor: move;  /* ‚Üê YENƒ∞: cursor deƒüi≈ütir */
}

    .header-left {
      display: flex;
      align-items: center;
      gap: 0px;
    }

    .logo-image {
      width: 48px; 
      height: 48px; 
      border-radius: 6px;
      pointer-events: auto;
      flex-shrink: 0;
      margin-right: 0px;
      margin-top: 2px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      background: #22c55e;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .logo {
  font-weight: 700;
  font-size: 14px;
  pointer-events: auto;
  padding: 0;
  padding-left: 0px;
  margin-left: -8px;
  white-space: nowrap;
  margin-right: 4px;
}

    .header-right {
      -webkit-app-region: no-drag;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .timer {
      font-size: 13px;
      color: white;
      font-weight: 600;
      pointer-events: auto;
    }

    .audio-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .audio-btn {
      background: #404040;
      border: none;
      cursor: pointer;
      padding: 3px 6px;
      pointer-events: auto;
      -webkit-app-region: no-drag;
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 16px;
      border-radius: 6px;
      transition: background 0.2s;
    }

    .audio-btn:hover {
      background: #4b5563;
    }

    .audio-icon {
      display: flex;
      align-items: center;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
      display: none;
      animation: pulse 2s infinite;
    }

    .audio-btn.enabled .status-indicator {
      display: block;
    }

    .end-session-btn {
      background: #ef4444;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 50%;
      font-size: 14px;
      cursor: pointer;
      font-weight: 600;
      pointer-events: auto;
      -webkit-app-region: no-drag;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
    }

    .end-session-btn:hover {
      background: #dc2626;
    }

    .hide-btn {
      background: #404040;
      color: white;
      border: none;
      padding: 3px 6px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
      pointer-events: auto; 
      -webkit-app-region: no-drag;
      position: relative;
    }

    .hide-btn:hover {
      background: #4b5563;
    }

    .hide-btn:hover::after {
      content: 'Ctrl+B';
      position: absolute;
      top: 100%;
      margin-top: 4px;
      right: -4px;
      background: #1f2937;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      pointer-events: none;
      z-index: 1000;
    }

    .listening-status {
      background: rgba(37, 37, 37, 0.5);
      padding: 10px 16px;
      border-bottom: 1px solid #404040;
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #9ca3af;
      overflow-x: auto;
      overflow-y: hidden;
      white-space: nowrap;
      scroll-behavior: smooth;
    }

    .listening-status::-webkit-scrollbar {
      display: none;
    }

    .listening-status {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    .listening-dot {
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .actions {
      -webkit-app-region: no-drag;
      padding: 12px 16px;
      display: flex;
      gap: 8px;
      background: rgba(37, 37, 37, 0.5);
      border-bottom: 1px solid #404040;
    }

    .action-btn {
      flex: 1;
      background: #3b82f6;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      pointer-events: auto;
    }

    .action-btn:hover {
      background: #2563eb;
    }

    .action-btn.secondary {
      background: #6b7280;
    }

    .action-btn.secondary:hover {
      background: #4b5563;
    }

    .content {
  flex: 1;
  overflow-y: auto;
  padding: 4px 8px;  /* 16px ‚Üí 8px 16px (√ºst-alt azalt) */
  display: flex;
  flex-direction: column;
  gap: 4px;  /* 16px ‚Üí 8px (elementler arasƒ± bo≈üluk azalt) */
  pointer-events: auto;  
}

    .content::-webkit-scrollbar {
      width: 8px;
    }

    .content::-webkit-scrollbar-thumb {
      background: #404040;
      border-radius: 4px;
    }

    .placeholder {
      color: #6b7280;
      font-style: italic;
    }

    body.minimized .content,
    body.minimized .actions,
    body.minimized .listening-status {
      display: none;
    }

    pre {
      background: #1e1e1e;
      border: 1px solid #404040;
      border-radius: 6px;
      padding: 12px;
      overflow-x: auto;
      margin: 8px 0;
    }

    code {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
      color: #e5e7eb;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .manual-input {
      -webkit-app-region: no-drag;
      padding: 6px 16px;
      display: flex;
      gap: 6px;
      background: rgba(37, 37, 37, 0.5);
      border-bottom: 1px solid #404040;
      align-items: center;
    }

    .message-input {
      flex: 1;
      background: #2d2d2d;
      border: 1px solid #404040;
      border-radius: 6px;
      padding: 6px 12px;
      color: white;
      font-size: 13px;
      pointer-events: auto;
      font-family: inherit;
    }

    .message-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .message-input::placeholder {
      color: #6b7280;
    }

    .send-btn {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      pointer-events: auto;
      -webkit-app-region: no-drag;
      white-space: nowrap;
    }

    .send-btn:hover {
      background: #2563eb;
    }

    .send-btn:disabled {
      background: #4b5563;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .question-balloon {
  background: #3b82f6;
  color: white;
  border-radius: 16px;
  padding: 12px 16px;
  margin-bottom: 4px;  /* 12px ‚Üí 8px (answer'a olan bo≈üluk azalt) */
  font-size: 14px;
  line-height: 1.5;
  pointer-events: auto;
}

    .question-balloon strong {
      color: white !important;
      font-weight: 700;
    }

    .answer-balloon {
  background: rgba(55, 55, 55, 0.8);
  color: #e5e7eb;
  border-radius: 16px;
  padding: 12px 16px;
  font-size: 14px;
  line-height: 1.6;
  border: 1px solid #404040;
  pointer-events: auto;
  margin-bottom: 250px; 
}

    .answer-balloon strong {
      color: #fbbf24 !important;
    }

    .answer-balloon pre {
      margin: 8px 0;
    }

    body.minimized .manual-input {
      display: none;
    }

    /* Conversation navigation */
    .conversation-nav {
  display: flex;
  align-items: center;
  gap: 3px;
  margin-bottom: 2px;  /* 8px ‚Üí 4px (question'a olan bo≈üluk azalt) */
  padding: 0;
  background: transparent;
  border: none;
}

    .nav-btn {
      background: rgba(64, 64, 64, 0.6);
      color: white;
      border: none;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 12px;
      cursor: pointer;
      pointer-events: auto;
      transition: background 0.2s;
      min-width: 22px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .nav-btn:hover:not(:disabled) {
      background: #4b5563;
    }

    .nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
/* Tooltip for shortcuts */
.action-btn {
  position: relative;
}

.action-btn::after {
  content: attr(data-shortcut);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 8px;
  background: #1f2937;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 10px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
}

.action-btn:hover::after {
  opacity: 1;
}

  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <img src="logo.png" class="logo-image" alt="InterviewsAI">
        <span class="logo">Interviews AI</span>
        <button class="hide-btn">Hide</button>
      </div>
      <div class="header-right">
        <span class="timer" id="timer">00:00</span>
        <div class="audio-controls">
          <button class="audio-btn enabled" id="speakerBtn" title="Desktop System Audio">
            <span class="audio-icon">
              <svg width="20" height="20" viewBox="0 0 32 32" fill="white">
                <path d="M28 4H4a2 2 0 00-2 2v16a2 2 0 002 2h9v2H9v2h14v-2h-4v-2h9a2 2 0 002-2V6a2 2 0 00-2-2zm0 18H4V6h24z"/>
                <rect x="6" y="8" width="20" height="12" rx="1" fill="white" opacity="0.3"/>
              </svg>
            </span>
            <span class="status-indicator"></span>
          </button>
          <button class="audio-btn enabled" id="micBtn" title="Microphone">
            <span class="audio-icon">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="white">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
              </svg>
            </span>
            <span class="status-indicator"></span>
          </button>
        </div>
        <button class="end-session-btn" title="End Session">‚úï</button>
      </div>
    </div>

    <div class="listening-status">
      <div class="listening-dot"></div>
      <span>Listening...</span>
    </div>

    <div class="content">
      <div class="conversation-nav">
  <button class="nav-btn" id="prevBtn" disabled title="Previous Question">&lt;</button>
  <button class="nav-btn" id="nextBtn" disabled title="Next Question">&gt;</button>
  
  <!-- Font size with zoom percentage -->
  <div style="flex: 1;"></div>
  <span style="font-size: 11px; color: #ffffff; display: flex; align-items: center; gap: 4px;">
    üîç <span id="zoomLevel">100%</span>
  </span>
  <button class="nav-btn" id="fontSizeDown" title="Decrease font size">‚àí</button>
  <button class="nav-btn" id="fontSizeUp" title="Increase font size">+</button>
</div>
<div id="question"></div>
<div id="answer"></div>
    </div>

    <div class="actions">
  <button class="action-btn" id="aiAnswerBtn" data-shortcut="Ctrl+G">‚ö° Generate Answer</button>
  <button class="action-btn secondary" id="analyzeScreenBtn" data-shortcut="Ctrl+K">üì∏ Analyze Screen</button>
</div>

    <div class="manual-input">
      <input type="text" id="manualMessage" placeholder="Type manual message here..." class="message-input"/>
      <button class="send-btn" id="sendBtn" disabled>Send</button>
    </div>
  </div>

  <script>
    let seconds = 0;
setInterval(() => {
  seconds++;
  const m = Math.floor(seconds / 60).toString().padStart(2, '0');
  const s = (seconds % 60).toString().padStart(2, '0');
  document.getElementById('timer').textContent = `${m}:${s}`;
}, 1000);

// ===== YENƒ∞: Her 10 saniyede bir backend'e kaydet =====
setInterval(async () => {
  if (sessionId && conversation.length > 0) {
    try {
      const chatContent = conversation
        .map(turn => {
          if (turn.from === 'question_summary') {
            return `USER QUESTION:\n${turn.text}\n`;
          }
          if (turn.from === 'ai') {
            return `AI RESPONSE:\n${turn.text}\n`;
          }
          return '';
        })
        .join('\n');
      
      const transcriptContent = conversation
        .filter(turn => turn.from === 'question_summary' && turn.rawText)
        .map(turn => turn.rawText.trim())
        .join('\n\n');
      
      const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
      const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
      const s = (seconds % 60).toString().padStart(2, '0');
      const duration = `${h}:${m}:${s}`;
      
      const API_URL = 'http://localhost:5000';
      
      await fetch(`${API_URL}/api/sessions/${sessionId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat: chatContent,
          transcript: transcriptContent,
          duration: duration,
          status: 'In Progress',
          settings: sessionSettings
        })
      });
      
      console.log('‚úÖ Auto-saved at', duration);
    } catch (error) {
      console.error('‚ùå Auto-save failed:', error);
    }
  }
}, 5000); 

    document.getElementById('aiAnswerBtn').addEventListener('click', async () => {
  // Hem final hem de interim transcript'i al
  const listeningSpan = document.querySelector('.listening-status span:last-child');
  const currentTranscript = listeningSpan.textContent.replace('Listening...', '').trim();
  
  // Final transcript varsa onu kullan, yoksa ≈üu anki g√∂r√ºnen transcript'i kullan
  const questionText = accumulatedTranscript.trim() || currentTranscript;
  
  if (!questionText) {
    alert('Please speak a question first!');
    return;
  }
      
      accumulatedTranscript = '';
      listeningSpan.textContent = 'Listening...';
      
      const questionDiv = document.getElementById('question');
      questionDiv.innerHTML = `<div class="question-balloon" style="font-size: ${currentFontSize}px;"><strong>QUESTION:</strong> ${questionText}</div>`;
      
      const answerDiv = document.getElementById('answer');
      answerDiv.innerHTML = '<span class="placeholder">Generating...</span>';
      
      try {
        const messages = conversation.map(turn => ({
          role: turn.from === 'ai' ? 'assistant' : 'user',
          content: turn.text
        }));
        messages.push({ role: 'user', content: questionText });
        
        const resumeString = sessionSettings?.selectedResume?.content || '';
        const API_URL = 'http://localhost:5000/api/chat';
        
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages,
            resumeString,
            interviewSessionId: sessionId,
            customPrompt: sessionSettings?.extraInstructions || ''
          })
        });
        
        if (!response.ok) throw new Error('Failed to get response');
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullStreamedText = '';
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');
          
          for (const line of lines) {
            if (line.startsWith('0:"')) {
              const content = line.slice(3, -1)
                .replace(/\\"/g, '"')
                .replace(/\\n/g, '\n')
                .replace(/\\r/g, '\r')
                .replace(/\\t/g, '\t')
                .replace(/\\\\/g, '\\');
              
              fullStreamedText += content;
              
              let formattedText = fullStreamedText
                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
              
              answerDiv.innerHTML = `<div class="answer-balloon" style="font-size: ${currentFontSize}px;"><strong>AI RESPONSE:</strong> ${formattedText}</div>`;
            }
          }
        }
        
        const baseId = Date.now();
        conversation.push({
          from: 'question_summary',
          text: questionText,
          id: baseId
        });
        conversation.push({
          from: 'ai',
          text: fullStreamedText,
          id: baseId + 1
        });
        
        console.log('‚úÖ Conversation updated:', conversation);
        refreshNavigation(); 
        
      } catch (error) {
        console.error('‚ùå Generate answer error:', error);
        answerDiv.innerHTML = '<span style="color: #ef4444;">Error: ' + error.message + '</span>';
      }
    });

    document.getElementById('analyzeScreenBtn').addEventListener('click', async () => {
      if (!sessionId && window.electronSessionId) {
        sessionId = window.electronSessionId;
      }
      
      if (!sessionId || isAnalyzing) return;
      
      setIsAnalyzing(true);
      
      const questionDiv = document.getElementById('question');
      questionDiv.innerHTML = `<div class="question-balloon" style="font-size: ${currentFontSize}px;"><strong>QUESTION:</strong> The interviewer is sharing their screen. Analyze the screen and provide a useful response.</div>`;
      
      const answerDiv = document.getElementById('answer');
      answerDiv.innerHTML = '<span class="placeholder">Capturing and analyzing screen...</span>';
      
      try {
        const screenshotBase64 = await require('electron').ipcRenderer.invoke('capture-screenshot');
        
        if (!screenshotBase64) throw new Error('Failed to capture screenshot');
        
        const userMessage = "The interviewer is sharing their screen. Analyze the screen and provide a useful response.";
        const messages = conversation.map(turn => ({
          role: turn.from === 'ai' ? 'assistant' : 'user',
          content: turn.text
        }));
        
        messages.push({
          role: 'user',
          content: userMessage,
          data: {
            task: 'analyze-screen',
            imageUrl: `data:image/png;base64,${screenshotBase64}`
          }
        });
        
        const resumeString = sessionSettings?.selectedResume?.content || '';
        const baseId = Date.now();
        
        conversation.push({
          from: 'question_summary',
          text: userMessage,
          rawText: userMessage,
          id: baseId
        });
        conversation.push({
          from: 'ai',
          text: '',
          id: baseId + 1
        });
        
        answerDiv.innerHTML = '<span class="placeholder">Analyzing...</span>';
        
        const API_URL = 'http://localhost:5000/api/chat';
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages,
            resumeString,
            interviewSessionId: sessionId,
            customPrompt: sessionSettings?.extraInstructions || ''
          })
        });
        
        if (!response.ok) throw new Error('Failed to analyze screen');
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullStreamedText = '';
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');
          
          for (const line of lines) {
            if (line.startsWith('0:"')) {
              const content = line.slice(3, -1)
                .replace(/\\"/g, '"')
                .replace(/\\n/g, '\n')
                .replace(/\\r/g, '\r')
                .replace(/\\t/g, '\t')
                .replace(/\\\\/g, '\\');
              
              fullStreamedText += content;
              
              let formattedText = fullStreamedText
                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
              
              answerDiv.innerHTML = `<div class="answer-balloon" style="font-size: ${currentFontSize}px;"><strong>AI RESPONSE:</strong> ${formattedText}</div>`;
              conversation[conversation.length - 1].text = fullStreamedText;
            }
          }
        }
        
        refreshNavigation();
        
      } catch (error) {
        console.error('‚ùå Screen analysis error:', error);
        answerDiv.innerHTML = '<span style="color: #ef4444;">Error: ' + error.message + '</span>';
      } finally {
        setIsAnalyzing(false);
      }
    });

    document.querySelector('.end-session-btn').addEventListener('click', async () => {
  if (confirm('Are you sure you want to end this session?')) {
    // ===== YENƒ∞: Session'ƒ± backend'e kaydet =====
    if (sessionId && conversation.length > 0) {
      try {
        const chatContent = conversation
          .map(turn => {
            if (turn.from === 'question_summary') {
              return `USER QUESTION:\n${turn.text}\n`;
            }
            if (turn.from === 'ai') {
              return `AI RESPONSE:\n${turn.text}\n`;
            }
            return '';
          })
          .join('\n');
        
        const transcriptContent = conversation
          .filter(turn => turn.from === 'question_summary' && turn.rawText)
          .map(turn => turn.rawText.trim())
          .join('\n\n');
        
        const duration = document.getElementById('timer').textContent;
        
        const API_URL = 'http://localhost:5000';
        
        await fetch(`${API_URL}/api/sessions/${sessionId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat: chatContent,
            transcript: transcriptContent,
            duration: duration,
            status: 'Completed',
            settings: sessionSettings
          })
        });
        
        console.log('‚úÖ Session saved to backend');
      } catch (error) {
        console.error('‚ùå Failed to save session:', error);
      }
    }
    
    require('electron').ipcRenderer.send('end-session');
  }
});

    let speakerEnabled = true;
    let micEnabled = true;

    document.getElementById('speakerBtn').addEventListener('click', () => {
      speakerEnabled = !speakerEnabled;
      const btn = document.getElementById('speakerBtn');
      btn.classList.toggle('enabled', speakerEnabled);
      toggleAudioSource('system', speakerEnabled);
    });

    document.getElementById('micBtn').addEventListener('click', () => {
      micEnabled = !micEnabled;
      const btn = document.getElementById('micBtn');
      btn.classList.toggle('enabled', micEnabled);
      toggleAudioSource('microphone', micEnabled);
    });

  // ===== YENƒ∞: Audio'yu HEMEN ba≈ülat =====
let audioPreparationPromise = null;

window.addEventListener('DOMContentLoaded', async () => {
  console.log('üéØ Overlay loaded');
  
  speakerEnabled = true;
  micEnabled = true;
  
  document.getElementById('speakerBtn').classList.add('enabled');
  document.getElementById('micBtn').classList.add('enabled');
  
  if (window.electronSessionId) {
    sessionId = window.electronSessionId;
  }
  
  const language = window.electronSessionSettings?.language || 'en-US';
  
  // ===== YENƒ∞: Audio'yu HEMEN hazƒ±rla (token beklemeden) =====
 console.log('üé§ Preparing audio sources immediately...');
audioPreparationPromise = (async () => {
  try {
    // 1. System audio'yu hazƒ±rla
    await prepareSystemAudio();
    
    // 2. Microphone'u hazƒ±rla
    const micStream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      } 
    });
    microphoneStream = micStream;
    console.log('‚úÖ Microphone ready');
    console.log('‚úÖ Audio sources ready!');
    return true;
  } catch (error) {
    console.error('‚ùå Failed to prepare audio:', error);
    return false;
  }
})();
  
  // Token'ƒ± iste (audio hazƒ±rlanƒ±rken paralel √ßalƒ±≈üacak)
  console.log('üîë Requesting Deepgram token...');
  
  // ===== Resume'√º arka planda bekle =====
  const checkResumeInterval = setInterval(() => {
    if (window.electronSessionSettings?.selectedResume?.content) {
      clearInterval(checkResumeInterval);
      console.log('‚úÖ Resume found in overlay!');
      console.log('üìÑ Resume length:', window.electronSessionSettings.selectedResume.content.length);
      sessionSettings = window.electronSessionSettings;
    } else {
      console.log('‚è≥ Waiting for resume data...');
    }
  }, 100);
  
  setTimeout(() => {
    clearInterval(checkResumeInterval);
    if (!sessionSettings?.selectedResume?.content) {
      console.error('‚ùå Resume data never arrived!');
    }
  }, 10000);
});

    document.querySelector('.hide-btn').addEventListener('click', () => {
      require('electron').ipcRenderer.send('hide-overlay');
    });

    require('electron').ipcRenderer.on('toggle-hide', () => {
      require('electron').ipcRenderer.send('hide-overlay');
    });

    // Ctrl+G kƒ±sayolu - Generate Answer
require('electron').ipcRenderer.on('generate-response', () => {
  console.log('Generate response shortcut triggered');
  document.getElementById('aiAnswerBtn').click();
});

// Ctrl+K kƒ±sayolu - Analyze Screen
require('electron').ipcRenderer.on('analyze-screen', () => {
  console.log('Analyze screen shortcut triggered');
  document.getElementById('analyzeScreenBtn').click();
});

    require('electron').ipcRenderer.on('toggle-minimize', (event, isMinimized) => {
      document.body.classList.toggle('minimized', isMinimized);
      document.querySelector('.hide-btn').textContent = isMinimized ? 'Show' : 'Hide';
    });

    document.addEventListener('mousemove', (e) => {
      const isOverInteractive = e.target.closest('button, .content, .header, .listening-status, .manual-input');
      
      try {
        if (isOverInteractive) {
          require('electron').ipcRenderer.send('set-ignore-mouse-events', false);
        } else {
          require('electron').ipcRenderer.send('set-ignore-mouse-events', true, { forward: true });
        }
      } catch (err) {
        console.error('Mouse event error:', err);
      }
    });

    const messageInput = document.getElementById('manualMessage');
    const sendBtn = document.getElementById('sendBtn');

    messageInput.addEventListener('input', () => {
      sendBtn.disabled = messageInput.value.trim().length === 0;
    });

    sendBtn.addEventListener('click', async () => {
  const message = messageInput.value.trim();
  if (!message) return;
  
  const manualQuestion = message;
  messageInput.value = '';
  sendBtn.disabled = true;
  
  const questionDiv = document.getElementById('question');
  questionDiv.innerHTML = `<div class="question-balloon" style="font-size: ${currentFontSize}px;"><strong>QUESTION:</strong> ${manualQuestion}</div>`;
  
  const answerDiv = document.getElementById('answer');
  answerDiv.innerHTML = '<span class="placeholder">Generating...</span>';
      
      try {
        const messages = conversation.map(turn => ({
          role: turn.from === 'ai' ? 'assistant' : 'user',
          content: turn.text
        }));
        messages.push({ role: 'user', content: manualQuestion });
        
        const resumeString = sessionSettings?.selectedResume?.content || '';
        const API_URL = 'http://localhost:5000/api/chat';
        
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages,
            resumeString,
            interviewSessionId: sessionId,
            customPrompt: sessionSettings?.extraInstructions || ''
          })
        });
        
        if (!response.ok) throw new Error('Failed to get response');
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullStreamedText = '';
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');
          
          for (const line of lines) {
  if (line.startsWith('0:"')) {
    const content = line.slice(3, -1)
      .replace(/\\"/g, '"')
      .replace(/\\n/g, '\n')
      .replace(/\\r/g, '\r')
      .replace(/\\t/g, '\t')
      .replace(/\\\\/g, '\\'); 
    
    fullStreamedText += content;
    
    let formattedText = fullStreamedText
      .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\n/g, '<br>');
    
    answerDiv.innerHTML = `<div class="answer-balloon" style="font-size: ${currentFontSize}px;"><strong>AI RESPONSE:</strong> ${formattedText}</div>`;
  }
}
        }
        
        const baseId = Date.now();
        conversation.push({
          from: 'question_summary',
          text: manualQuestion,
          id: baseId
        });
        conversation.push({
          from: 'ai',
          text: fullStreamedText,
          id: baseId + 1
        });
        
        refreshNavigation();
        
      } catch (error) {
        console.error('‚ùå Manual message error:', error);
        answerDiv.innerHTML = '<span style="color: #ef4444;">Error: ' + error.message + '</span>';
      }
    });

    let accumulatedTranscript = '';
    let sessionSettings = null;
    let sessionId = null;
    let conversation = [];

    const { createClient, LiveTranscriptionEvents } = require('@deepgram/sdk');

    let deepgramConnection = null;
    let microphoneStream = null;
    let systemAudioStream = null;
    let combinedRecorder = null;
    let audioContext = null;
    let isCapturing = false;
    let isAnalyzing = false;

    function setIsAnalyzing(value) {
      isAnalyzing = value;
      document.getElementById('analyzeScreenBtn').disabled = value;
    }

    let micSourceNode = null;
    let systemSourceNode = null;
    let gainNodes = { mic: null, system: null };

    require('electron').ipcRenderer.on('deepgram-token', async (event, data) => {
  try {
    // Audio hazƒ±r mƒ± bekle
    console.log('‚è≥ Waiting for audio sources...');
    const audioReady = await audioPreparationPromise;
    
    if (!audioReady) {
      throw new Error('Audio preparation failed');
    }
    
    console.log('‚úÖ Audio ready, starting Deepgram...');
    
    const deepgram = createClient(data.token);
    deepgramConnection = deepgram.listen.live({
      model: 'nova-2',
      language: data.language,
      smart_format: true,
      interim_results: true,
    });

    deepgramConnection.on(LiveTranscriptionEvents.Open, async () => {  // ‚Üê async ekle
      isCapturing = true;
      console.log('‚úÖ Deepgram connected!');
      
      // ===== YENƒ∞: Deepgram OPEN olduktan SONRA recorder ba≈ülat =====
      try {
        await startCombinedAudioFast();
        console.log('‚úÖ Recording started after Deepgram connected!');
      } catch (error) {
        console.error('‚ùå Failed to start recording:', error);
      }
    });

    deepgramConnection.on(LiveTranscriptionEvents.Transcript, (transcriptData) => {
      const transcriptText = transcriptData.channel.alternatives[0].transcript;
      console.log('üìù Transcript received:', transcriptText); // ‚Üê YENƒ∞ LOG
      
      if (transcriptText) {
        const listeningStatusDiv = document.querySelector('.listening-status');
        const listeningSpan = listeningStatusDiv.querySelector('span:last-child');
        
        if (transcriptData.is_final) {
          accumulatedTranscript += (accumulatedTranscript ? ' ' : '') + transcriptText;
          listeningSpan.textContent = accumulatedTranscript;
        } else {
          listeningSpan.innerHTML = `${accumulatedTranscript}<span style="color: #9ca3af;">${accumulatedTranscript ? ' ' : ''}${transcriptText}</span>`;
        }
        
        listeningStatusDiv.scrollLeft = listeningStatusDiv.scrollWidth;
      }
    });

    deepgramConnection.on(LiveTranscriptionEvents.Error, (err) => {
      console.error('‚ùå Deepgram error:', err);
    });

    deepgramConnection.on(LiveTranscriptionEvents.Close, () => {
      isCapturing = false;
      console.log('üî¥ Deepgram closed');
    });

    // ===== ESKƒ∞ KODU KALDIR - artƒ±k OPEN event'inde ba≈ülatƒ±yoruz =====
    // await startCombinedAudioFast(); ‚Üê BU SATIRI Sƒ∞L

  } catch (error) {
    console.error('Failed to start audio capture:', error);
    alert('Failed to start audio: ' + error.message);
  }
});

// YENƒ∞ FONKSƒ∞YON: Hazƒ±r audio ile hƒ±zlƒ± ba≈ülatma
async function startCombinedAudioFast() {
  try {
    audioContext = new AudioContext();
    const destination = audioContext.createMediaStreamDestination();
    
    micSourceNode = audioContext.createMediaStreamSource(microphoneStream);
    gainNodes.mic = audioContext.createGain();
    gainNodes.mic.gain.value = micEnabled ? 1 : 0;
    
    micSourceNode.connect(gainNodes.mic);
    gainNodes.mic.connect(destination);
    
    if (systemAudioStream) {
      systemSourceNode = audioContext.createMediaStreamSource(systemAudioStream);
      gainNodes.system = audioContext.createGain();
      gainNodes.system.gain.value = speakerEnabled ? 1 : 0;
      
      systemSourceNode.connect(gainNodes.system);
      gainNodes.system.connect(destination);
    }
    
    const mediaRecorder = new MediaRecorder(destination.stream, {
      mimeType: 'audio/webm;codecs=opus'
    });
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0 && deepgramConnection && deepgramConnection.getReadyState() === 1) {
        deepgramConnection.send(event.data);
      }
    };
    
    mediaRecorder.start(250);
    combinedRecorder = mediaRecorder;
    
    console.log('‚úÖ Audio recording started!');
  } catch (error) {
    console.error('‚ùå Failed to start combined audio:', error);
    throw error;
  }
}

    require('electron').ipcRenderer.on('stop-audio-capture', () => {
      stopAudioCapture();
    });

    async function prepareSystemAudio() {
  try {
    const sources = await require('electron').ipcRenderer.invoke('get-desktop-sources');
    
    if (!sources || sources.length === 0) {
      console.log('‚ö†Ô∏è No desktop sources found');
      return;
    }
    
    const primarySource = sources[0];
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: primarySource.id
        }
      },
      video: {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: primarySource.id,
          maxWidth: 1,
          maxHeight: 1
        }
      }
    });
    
    const audioTrack = stream.getAudioTracks()[0];
    if (audioTrack) {
      systemAudioStream = new MediaStream([audioTrack]);
      console.log('‚úÖ System audio prepared');
    }
    
    // Video track'leri kapat
    stream.getVideoTracks().forEach(track => track.stop());
    
  } catch (error) {
    console.warn('‚ö†Ô∏è System audio not available:', error.message);
  }
}

    async function startCombinedAudio() {
      try {
        const micStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          } 
        });
        
        microphoneStream = micStream;
        audioContext = new AudioContext();
        const destination = audioContext.createMediaStreamDestination();
        
        micSourceNode = audioContext.createMediaStreamSource(micStream);
        gainNodes.mic = audioContext.createGain();
        gainNodes.mic.gain.value = micEnabled ? 1 : 0;
        
        micSourceNode.connect(gainNodes.mic);
        gainNodes.mic.connect(destination);
        
        if (systemAudioStream) {
          systemSourceNode = audioContext.createMediaStreamSource(systemAudioStream);
          gainNodes.system = audioContext.createGain();
          gainNodes.system.gain.value = speakerEnabled ? 1 : 0;
          
          systemSourceNode.connect(gainNodes.system);
          gainNodes.system.connect(destination);
        }
        
        const mediaRecorder = new MediaRecorder(destination.stream, {
          mimeType: 'audio/webm;codecs=opus'
        });
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0 && deepgramConnection && deepgramConnection.getReadyState() === 1) {
            deepgramConnection.send(event.data);
          }
        };
        
        mediaRecorder.start(250);
        combinedRecorder = mediaRecorder;
        
      } catch (error) {
        console.error('‚ùå Failed to start combined audio:', error);
        throw error;
      }
    }

    function stopAudioCapture() {
      if (combinedRecorder) {
        combinedRecorder.stop();
        combinedRecorder = null;
      }

      micSourceNode = null;
      systemSourceNode = null;
      gainNodes = { mic: null, system: null };

      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      if (deepgramConnection) {
        deepgramConnection.finish();
        deepgramConnection = null;
      }

      if (microphoneStream) {
        microphoneStream.getTracks().forEach(track => track.stop());
        microphoneStream = null;
      }

      if (systemAudioStream) {
        systemAudioStream.getTracks().forEach(track => track.stop());
        systemAudioStream = null;
      }

      isCapturing = false;
    }

    function toggleAudioSource(source, enabled) {
      if (!audioContext) return;
      
      try {
        if (source === 'microphone') {
          if (micSourceNode && gainNodes.mic) {
            gainNodes.mic.gain.value = enabled ? 1 : 0;
          }
        } else if (source === 'system') {
          if (systemSourceNode && gainNodes.system) {
            gainNodes.system.gain.value = enabled ? 1 : 0;
          }
        }
      } catch (error) {
        console.error('Failed to toggle audio source:', error);
      }
    }

    let currentConversationIndex = -1;

    function updateNavigationButtons() {
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      
      const questionAnswerPairs = [];
      for (let i = 0; i < conversation.length; i += 2) {
        if (conversation[i] && conversation[i + 1]) {
          questionAnswerPairs.push({
            question: conversation[i],
            answer: conversation[i + 1]
          });
        }
      }
      
      const totalPairs = questionAnswerPairs.length;
      
      if (totalPairs === 0) {
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        return;
      }
      
      if (currentConversationIndex === -1 || currentConversationIndex >= totalPairs) {
        currentConversationIndex = -1;
        prevBtn.disabled = totalPairs <= 1;
        nextBtn.disabled = true;
      } else {
        prevBtn.disabled = currentConversationIndex === 0;
        nextBtn.disabled = currentConversationIndex === totalPairs - 1;
      }
    }

    function showConversationAtIndex(index) {
      const questionAnswerPairs = [];
      for (let i = 0; i < conversation.length; i += 2) {
        if (conversation[i] && conversation[i + 1]) {
          questionAnswerPairs.push({
            question: conversation[i],
            answer: conversation[i + 1]
          });
        }
      }
      
      if (index === -1) {
        currentConversationIndex = -1;
        updateNavigationButtons();
        return;
      }
      
      if (index >= 0 && index < questionAnswerPairs.length) {
        const pair = questionAnswerPairs[index];
        
        const questionDiv = document.getElementById('question');
        questionDiv.innerHTML = `<div class="question-balloon" style="font-size: ${currentFontSize}px;"><strong>QUESTION:</strong> ${pair.question.text}</div>`;
        
        const answerDiv = document.getElementById('answer');
        let formattedText = pair.answer.text
          .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\n/g, '<br>');
        
        answerDiv.innerHTML = `<div class="answer-balloon" style="font-size: ${currentFontSize}px;"><strong>AI RESPONSE:</strong> ${formattedText}</div>`;
        
        currentConversationIndex = index;
        updateNavigationButtons();
      }
    }

    document.getElementById('prevBtn').addEventListener('click', () => {
      if (currentConversationIndex === -1) {
        const questionAnswerPairs = [];
        for (let i = 0; i < conversation.length; i += 2) {
          if (conversation[i] && conversation[i + 1]) {
            questionAnswerPairs.push({
              question: conversation[i],
              answer: conversation[i + 1]
            });
          }
        }
        showConversationAtIndex(questionAnswerPairs.length - 2);
      } else {
        showConversationAtIndex(currentConversationIndex - 1);
      }
    });

    document.getElementById('nextBtn').addEventListener('click', () => {
      const questionAnswerPairs = [];
      for (let i = 0; i < conversation.length; i += 2) {
        if (conversation[i] && conversation[i + 1]) {
          questionAnswerPairs.push({
            question: conversation[i],
            answer: conversation[i + 1]
          });
        }
      }
      
      if (currentConversationIndex === questionAnswerPairs.length - 1) {
        showConversationAtIndex(-1);
      } else {
        showConversationAtIndex(currentConversationIndex + 1);
      }
    });

    function refreshNavigation() {
      currentConversationIndex = -1;
      updateNavigationButtons();
    }

    // Font size control
let currentFontSize = 14; // Default 100%

document.getElementById('fontSizeUp').addEventListener('click', () => {
  // Her tƒ±klamada 1.4px artƒ±r (14px'in %10'u)
  if (currentFontSize < 19.6) { // Max ~140%
    currentFontSize += 1.4;
    updateFontSize();
  }
});

document.getElementById('fontSizeDown').addEventListener('click', () => {
  // Her tƒ±klamada 1.4px azalt (14px'in %10'u)
  if (currentFontSize > 9.8) { // Min ~70%
    currentFontSize -= 1.4;
    updateFontSize();
  }
});

function updateFontSize() {
  const questionBalloons = document.querySelectorAll('.question-balloon');
  const answerBalloons = document.querySelectorAll('.answer-balloon');
  
  questionBalloons.forEach(balloon => {
    balloon.style.fontSize = currentFontSize + 'px';
  });
  
  answerBalloons.forEach(balloon => {
    balloon.style.fontSize = currentFontSize + 'px';
  });
  
  // Update zoom percentage (14px = 100%)
  const zoomPercent = Math.round((currentFontSize / 14) * 100);
  document.getElementById('zoomLevel').textContent = zoomPercent + '%';
  
  console.log('‚úÖ Font size updated to:', currentFontSize.toFixed(1) + 'px', '(' + zoomPercent + '%)');
}
  </script>
</body>
</html>